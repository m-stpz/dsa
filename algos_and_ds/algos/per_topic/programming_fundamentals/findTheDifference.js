/*  
You are given two strings s and t.

String t is generated by random shuffling string s and then add one more letter at a random position.

Return the letter that was added to t.

Example 1:

Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.
Example 2:

Input: s = "", t = "y"
Output: "y"
 
Constraints:

0 <= s.length <= 1000
t.length == s.length + 1
s and t consist of lowercase English letters.

=== Algo design ===
s = "abcd", t = "abcde"

"st"
"t"

map = {
    a: "s"
}

sMap = {
    a: 1
    b: 1
    c: 1
    d: 1
}

tMap = {
    a: 1
    b: 1
    c: 1
    d: 1
    e => this doesn't existing in sMap
}

- return the tMap[key] that doesn't exist in sMap 

=== Pseudocode ===
tMap = {}

loop over t
    sChar = s[i]
    tChar = t[i]

    if (tMap[tChar] !== sChar){
        return tChar
    }

    add elements to the maps 
    tMap[tChar] = sChar

=== Big O analysis === 
t: O(n)
    n = t.length 
    t.length = s.length + 1
s: O(1)
    even though we need extra memory for the new maps,
    there are only 26 letters in the alphabet. There are our keys, so they can't grow beyond 26
    - The keys would (in case that's repeated letter), however, that's constant time
*/

var findTheDifference = function (s, t) {
  let sMap = {};
  let tMap = {};

  for (let char of s) {
    if (!sMap[char]) {
      sMap[char] = 1;
    } else {
      sMap[char] += 1;
    }
  }

  for (let char of t) {
    if (!tMap[char]) {
      tMap[char] = 1;
    } else {
      tMap[char] += 1;
    }
  }

  for (let [key, value] of Object.entries(tMap)) {
    if (!sMap[key] || value !== sMap[key]) {
      return key;
    }
  }
};

findTheDifference("a", "aa");

function findTheDifference2(s, t) {
  let map = {};

  for (const char of s) {
    // other alternative
    // #1. ternary: map[char] = map[char] ? map[char] + 1 : 1
    // #2. logical or: map[char] = (map[char] || 0) + 1 => we either either the map char it's there, or we set it to 0 + 1 = 1

    if (!map[char]) {
      map[char] = 1;
    } else {
      map[char] += 1;
    }
  }

  for (const char of t) {
    if (!map[char]) {
      return char;
    }
    // we also need to subtract the entries from the map
    map[char]--;
  }
}

/* 
# Post Mortem

Problem: Find the difference 
Problem statement (one-liner): Identify the element in t that it's not in s
Link: https://leetcode.com/problems/find-the-difference
Date: 11.11.25

### Algorithm

1. Pattern used: hash map
2. Key idea (short explanation):
    - build 2 maps: smap and tmap
        - if no key, initialize it with one
        - else, increase the key's value
    - compare the maps
        - identify if:
            - the element in tmap doesn't exist in smap
            - the count in tmap is not equal to smap 
        - if that's the case, that's the difference
3. Time to design the algorithm: 20min
4. Time to code: 10min
5. What solutions did I consider/miss?
    - Considered:
        - using hash map to solve it
    - Missed:
        I think I was able to solve it well
6. Was your solution optimal?
    - Not necessarily, there were other more optimal solutions, which involved some weird bit manipulation,
    but I prefer mine for clarity
7. What triggers did I find/miss?
8. Any mistakes I keep making?
   - Any bugs I should add to the Bug List?
9. What could I have done differently?
10. Takeaways
11. Is there anything I should add to my cheat sheet?
    Initiliaze or increment dict

### Self-rating

1(terrible) - 5(amazing)

Problem solving: 5
Coding: 5
Verification: 5
Communication: 5
*/
